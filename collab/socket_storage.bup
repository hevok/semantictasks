###
#SocketStorage#

This is a Socket storage adaptor needed to connect Batman's models to websocket
It has not been finished yet.
###


#_require ./socket_event.coffee
#_require ./channel.coffee
#_require ./socket.coffee
#_require ./mock_storage.coffee

class Batman.SocketStorage extends Batman.StorageAdapter
  ###
  #SocketStorage#

  This is a Socket storage adaptor needed to connect Batman's models to websocket
  It has not been finished yet.
  ###

  constructor: ->
    super
    @socket = new Batman.Socket.getInstance()


  ###
  _storageEntriesMatching: (constructor, options) ->
    re = @storageRegExpForRecord(constructor.prototype)
    records = []
    @_forAllStorageEntries (storageKey, storageString) ->
      if keyMatches = re.exec(storageKey)
        data = @_jsonToAttributes(storageString)
        data[constructor.primaryKey] = keyMatches[1]
        records.push data if @_dataMatches(options, data)
    records
  ###

  readAll: @skipIfError (env, next) ->
    ###
    overrided readAll to add subscription
    ###
    model = env.subject
    key = model.storageKey
    channel = @socket.getChannel(key)
    ###
    channel.onmessage = (event)=>
      all = model.get("all")
      all.add(event.content)

    channel.once key,(event)->
      unless event.content=="_nil_"
        try
          #arguments[0].recordsAttributes = @_storageEntriesMatching(env.subject, env.options.data)
          records = []
          for item in event.content
            data = item
            records.push data
          arguments[0] = records
        catch error
          arguments[0].error = error
      next()
    channel.readAll()
    ###
    next()

  @::before 'read', 'create', 'update', 'destroy', @skipIfError (env, next) ->
    if env.action == 'create'
      env.id = env.subject.get('id') || env.subject._withoutDirtyTracking => env.subject.set('id', Batman.SocketEvent.getnId())
    else
      env.id = env.subject.get('id')

    unless env.id?
      env.error = new @constructor.StorageError("Couldn't get/set record primary key on #{env.action}!")
    else
      #env.key = @storageKey(env.subject) + env.id
      key = @storageKey(env.subject)
      env.id = env.id
      env.channel = @socket.getChannel(key)
    next()

  create: @skipIfError ({channel, id, recordAttributes}, next) ->
    recordAttributes.id = id
    #channel.save(recordAttributes)
    next()

  update: @skipIfError ({channel, id, recordAttributes}, next) ->
    recordAttributes.id = id
    #channel.save(recordAttributes)
    next()

  destroy: @skipIfError ({channel,id}, next) ->
    channel.remove(id)
    next()

  read: @skipIfError (env, next) ->
    channel.once "read", (event)->
      env.recordAttributes = event.content
      if !env.recordAttributes then env.error = new @constructor.NotFoundError()
      next()
    id = env.id
    channel.read(id)

  #################COPY PASTED CODE LIES UNDERNEATH########################

  _dataMatches: (conditions, data) ->
    match = true
    for k, v of conditions
      if data[k] != v
        match = false
        break
    match


  @::before 'create', 'update', @skipIfError (env, next) ->
    env.recordAttributes = JSON.stringify(env.subject)
    next()

  @::after 'read', @skipIfError (env, next) ->
    if typeof env.recordAttributes is 'string'
      try
        env.recordAttributes = @_jsonToAttributes(env.recordAttributes)
      catch error
        env.error = error
        return next()
    env.subject._withoutDirtyTracking -> @fromJSON env.recordAttributes
    next()

  @::after 'read', 'create', 'update', 'destroy', @skipIfError (env, next) ->
    env.result = env.subject
    next()

  @::after 'readAll', @skipIfError (env, next) ->
    env.result = env.records = for recordAttributes in env.recordsAttributes
      @getRecordFromData(recordAttributes, env.subject)
    next()

