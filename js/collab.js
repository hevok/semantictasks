// Generated by CoffeeScript 1.6.1
(function() {
  var _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Batman.MockStorage = (function() {

    function MockStorage() {
      this.storage = localStorage;
    }

    MockStorage.prototype.getItem = function(key) {
      return this.storage.getItem(key);
    };

    MockStorage.prototype.setItem = function(key, value) {
      return this.storage.setItem(key, value);
    };

    MockStorage.prototype.removeItem = function(key) {
      return this.storage.removeItem(key);
    };

    MockStorage.prototype.length = function() {
      return this.storage.length;
    };

    MockStorage.prototype.key = function(i) {
      return this.storage.key(i);
    };

    return MockStorage;

  })();

  Batman.SocketStorage = (function(_super) {

    __extends(SocketStorage, _super);

    function SocketStorage() {
      var _this = this;
      this.subscribe = function(model, storageKey) {
        return SocketStorage.prototype.subscribe.apply(_this, arguments);
      };
      SocketStorage.__super__.constructor.apply(this, arguments);
      this.socket = new Batman.Socket.getInstance();
      this.storage = new Batman.MockStorage();
    }

    /*
    subscribes a model to the channel
    */


    SocketStorage.prototype.subscribe = function(model, storageKey) {
      var _this = this;
      this.channel = this.socket.newChannel(storageKey);
      return this.channel.onmessage = function(event) {
        var all;
        all = model.get("all");
        return all.add(event.content);
      };
    };

    SocketStorage.prototype._forAllStorageEntries = function(iterator) {
      var i, key, _i, _ref;
      for (i = _i = 0, _ref = this.storage.length(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        key = this.storage.key(i);
        iterator.call(this, key, this.storage.getItem(key));
      }
      return true;
    };

    SocketStorage.prototype.readAll = SocketStorage.skipIfError(function(env, next) {
      var key, model;
      try {
        arguments[0].recordsAttributes = this._storageEntriesMatching(env.subject, env.options.data);
      } catch (error) {
        arguments[0].error = error;
      }
      model = env.subject;
      key = model.storageKey;
      this.subscribe(model, key);
      return next();
    });

    /*
      ##Generates GUI as id for a record
    */


    SocketStorage.prototype.nextIdForRecord = function() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r, v;
        r = Math.random() * 16 | 0;
        v = (c === "x" ? r : r & 0x3 | 0x8);
        return v.toString(16);
      });
    };

    SocketStorage.prototype.before('read', 'create', 'update', 'destroy', SocketStorage.skipIfError(function(env, next) {
      var _this = this;
      if (env.action === 'create') {
        env.id = env.subject.get('id') || env.subject._withoutDirtyTracking(function() {
          return env.subject.set('id', _this.nextIdForRecord());
        });
      } else {
        env.id = env.subject.get('id');
      }
      if (env.id == null) {
        env.error = new this.constructor.StorageError("Couldn't get/set record primary key on " + env.action + "!");
      } else {
        env.key = env.id;
      }
      return next();
    }));

    SocketStorage.prototype.create = SocketStorage.skipIfError(function(_arg, next) {
      var key, recordAttributes;
      key = _arg.key, recordAttributes = _arg.recordAttributes;
      console.log(key);
      console.log(recordAttributes);
      if (this.storage.getItem(key)) {
        arguments[0].error = new this.constructor.RecordExistsError;
      } else {
        this.storage.setItem(key, recordAttributes);
      }
      return next();
    });

    SocketStorage.prototype.update = SocketStorage.skipIfError(function(_arg, next) {
      var key, recordAttributes;
      key = _arg.key, recordAttributes = _arg.recordAttributes;
      this.storage.setItem(key, recordAttributes);
      return next();
    });

    SocketStorage.prototype.destroy = SocketStorage.skipIfError(function(_arg, next) {
      var key;
      key = _arg.key;
      this.storage.removeItem(key);
      return next();
    });

    SocketStorage.prototype._storageEntriesMatching = function(constructor, options) {
      var re, records;
      re = this.storageRegExpForRecord(constructor.prototype);
      records = [];
      this._forAllStorageEntries(function(storageKey, storageString) {
        var data, keyMatches;
        if (keyMatches = re.exec(storageKey)) {
          data = this._jsonToAttributes(storageString);
          data[constructor.primaryKey] = keyMatches[1];
          if (this._dataMatches(options, data)) {
            return records.push(data);
          }
        }
      });
      return records;
    };

    SocketStorage.prototype._dataMatches = function(conditions, data) {
      var k, match, v;
      match = true;
      for (k in conditions) {
        v = conditions[k];
        if (data[k] !== v) {
          match = false;
          break;
        }
      }
      return match;
    };

    SocketStorage.prototype.before('create', 'update', SocketStorage.skipIfError(function(env, next) {
      env.recordAttributes = JSON.stringify(env.subject);
      return next();
    }));

    SocketStorage.prototype.after('read', SocketStorage.skipIfError(function(env, next) {
      if (typeof env.recordAttributes === 'string') {
        try {
          env.recordAttributes = this._jsonToAttributes(env.recordAttributes);
        } catch (error) {
          env.error = error;
          return next();
        }
      }
      env.subject._withoutDirtyTracking(function() {
        return this.fromJSON(env.recordAttributes);
      });
      return next();
    }));

    SocketStorage.prototype.after('read', 'create', 'update', 'destroy', SocketStorage.skipIfError(function(env, next) {
      env.result = env.subject;
      return next();
    }));

    SocketStorage.prototype.after('readAll', SocketStorage.skipIfError(function(env, next) {
      var recordAttributes;
      env.result = env.records = (function() {
        var _i, _len, _ref, _results;
        _ref = env.recordsAttributes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          recordAttributes = _ref[_i];
          _results.push(this.getRecordFromData(recordAttributes, env.subject));
        }
        return _results;
      }).call(this);
      return next();
    }));

    SocketStorage.prototype.read = SocketStorage.skipIfError(function(env, next) {
      env.recordAttributes = this.storage.getItem(env.key);
      if (!env.recordAttributes) {
        env.error = new this.constructor.NotFoundError();
      }
      return next();
    });

    return SocketStorage;

  })(Batman.StorageAdapter);

  /* Channel class
  evey socket sends info for various channels
  to channels the models will be binded
  each model will have a channel that is connected to its storage key
  */


  Batman.Channel = (function(_super) {

    __extends(Channel, _super);

    function Channel(name) {
      var _this = this;
      this.name = name;
      this.attach = function(obj) {
        return Channel.prototype.attach.apply(_this, arguments);
      };
      this.onmessage = function(event) {
        return Channel.prototype.onmessage.apply(_this, arguments);
      };
      this.receive = function(event) {
        return Channel.prototype.receive.apply(_this, arguments);
      };
      this.send = function(obj) {
        return Channel.prototype.send.apply(_this, arguments);
      };
    }

    Channel.prototype.send = function(obj) {
      return fire("send", obj);
    };

    Channel.prototype.receive = function(event) {
      return this.onmessage(event);
    };

    Channel.prototype.onmessage = function(event) {};

    Channel.prototype.attach = function(obj) {
      var _this = this;
      obj.on(this.name, function(event) {
        return _this.receive(event);
      });
      obj.on("all", function(event) {
        return _this.receive(event);
      });
      return this;
    };

    return Channel;

  })(Batman.Object);

  Batman.MockSocket = (function(_super) {

    __extends(MockSocket, _super);

    function MockSocket(url) {
      var _this = this;
      this.url = url;
      this.randomInt = function(min, max) {
        return MockSocket.prototype.randomInt.apply(_this, arguments);
      };
      this.onclose = function() {
        return MockSocket.prototype.onclose.apply(_this, arguments);
      };
      this.onmessage = function(event) {
        return MockSocket.prototype.onmessage.apply(_this, arguments);
      };
      this.onopen = function() {
        return MockSocket.prototype.onopen.apply(_this, arguments);
      };
      this.send = function(event) {
        return MockSocket.prototype.send.apply(_this, arguments);
      };
    }

    MockSocket.prototype.send = function(event) {
      if (typeof event === 'string') {
        return this.onmessage({
          data: event
        });
      } else {
        if (event.hasOwnProperty("data")) {
          return this.onmessage(event);
        } else {
          return this.onmessage({
            data: JSON.stringify(event)
          });
        }
      }
    };

    MockSocket.prototype.onopen = function() {
      return console.log("open");
    };

    MockSocket.prototype.onmessage = function(event) {
      var data;
      data = event.data;
      return console.log("onmessage: " + data);
    };

    MockSocket.prototype.onclose = function() {
      return console.log("close");
    };

    MockSocket.prototype.randomInt = function(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    };

    return MockSocket;

  })(Batman.Object);

  Batman.Socket = (function(_super) {

    __extends(Socket, _super);

    function Socket(url) {
      var _this = this;
      this.url = url;
      this.newChannel = function(name) {
        return Socket.prototype.newChannel.apply(_this, arguments);
      };
      this.createInnerSocket = function(url) {
        return Socket.prototype.createInnerSocket.apply(_this, arguments);
      };
      this.socket = Batman.container.hasOwnProperty("websocket") ? Batman.container["websocket"] : this.createInnerSocket(this.url);
      this.socket.onmessage = function(event) {
        return _this.broadcast(Batman.SocketEvent.fromEvent(event));
      };
      Batman.container.socket = this;
    }

    Socket.getInstance = function(url) {
      if (url == null) {
        url = "none";
      }
      if (Batman.container.hasOwnProperty("socket")) {
        return Batman.container.socket;
      } else {
        return new Batman.Socket(url);
      }
    };

    Socket.prototype.createInnerSocket = function(url) {
      this.socket = url !== "none" ? new WebSocket(this.url) : new Batman.MockSocket(this.url);
      return Batman.container.websocket = this.socket;
    };

    /*
    broadcasts the message further
    */


    Socket.prototype.broadcast = function(event) {
      if (!(event instanceof Batman.SocketEvent)) {
        throw Error('should be socket event');
      }
      return this.fire(event.channel, event);
    };

    Socket.prototype.newChannel = function(name) {
      return new Batman.Channel(name).attach(this);
    };

    Socket.prototype.send = function(obj) {
      var json;
      if (typeof obj === 'string') {
        json = {
          data: obj
        };
      } else {
        json = obj;
      }
      return this.socket.send(json);
    };

    /*
    
    #duplication to be fixed in the Future
    send: (obj, channelName) ->
    
      if typeof obj == 'string'
        json = data: obj
      else
        json = obj
      json.channel = channelName
      @socket.send(json)
    */


    return Socket;

  }).call(this, Batman.Object);

  /*
  This event is needed for convenient packing of the event info
  */


  Batman.SocketEvent = (function() {

    function SocketEvent(content, channel, request) {
      this.content = content;
      this.channel = channel;
      this.request = request != null ? request : "push";
    }

    SocketEvent.fromEvent = function(event) {
      if (!event.hasOwnProperty("data")) {
        throw new Error("No data inside of websocket event");
      }
      return this.fromData(event.data);
    };

    SocketEvent.fromData = function(data) {
      var channel, content, request;
      channel = data.hasOwnProperty("channel") ? data.channel : "default";
      content = data.hasOwnProperty("content") ? data.content : data;
      request = data.hasOwnProperty("request") ? data.request : "push";
      return new Batman.SocketEvent(content, channel, request);
    };

    return SocketEvent;

  })();

}).call(this);
